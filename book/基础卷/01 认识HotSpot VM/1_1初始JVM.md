[toc]

# 初始JVM

==JVM是Java Virtual Machine(Java虚拟机）的缩写，它是在实际的计算机上仿真、模拟计算机的各种功能==。
JVM的构成主要包括如下几点：

- ==一个抽象规范==：其中定义了JVM到底是什么，由哪些组成部分。这些抽象的规范在Java虚拟机规范（The Java Virtual Machine Specification,JVMS)中进行了详细描述。
- ==一个具体的实现==：具体的实现过程不仅需要不同的厂商要遵循Java虚拟机规范，而且还要根据每个平台的不同特性以软件或软硬结合的方式去实现设定的功能。
- ==一个运行的实例==：当用JVM运行一个Java程序时，这个Java程序就是一个运行中的实例，每个运行中的Java程序都是一个JVM实例。

==JVM定义了一套自己的指令集，即JVM字节码指令集，符合Class文件规范的字节码都可以被JVM解析、编译并执行==。JVM的结构如图1-1所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230511/image.7cmlt9p7y0o0.webp)

下面简单介绍JVM结构的各个组成部分。

- ==前端编译器==：主要负责将Java源代码转换为Class文件的字节码。

- ==类加载器==：在JVM启动时或者类运行时将需要的Class文件加载到JVM中。

- ==执行引擎==：负责执行Class文件中包含的字节码

- ==内存空间==：将JVM需要的内存可以划分成若干个区。其中：

	- ==Java栈用于存放函数的参数值和局部变量值==等，会自动分配释放；

	- ==Java堆用于存放对象和数组==，由JVM的垃圾收集器管理；
	- ==本地方法栈存放方法的元数据==，占用的内存也会在必要时由垃圾收集器进行回收。

- ==垃圾收集器==：负责对内存进行自动管理，自动回收一些不再使用的对象，以达到释放内存的目的。
- ==本地方法接口==：调用C或C++实现本地方法库中的方法并返回结果。

## 下面详细介绍JVM中几个重要的组成部分

### 1.类加载器

==类加载器主要负责类的装载==，包括启动类加载器（Bootstrap ClassLoader)、扩展类加载器（Extension ClassLoader)和应用类加载器（Application ClassLoader)。==每个被JVM装载的类型都有一个对应的java.lang.Class类的实例，这个实例和其他类的实例一样被存放在Java堆中==。

### 2.执行引擎

==执行引擎是JVM的核心部分，其作用是执行Class文件中的字节码指令==。在Java虚拟机规范中详细定义了执行引擎遇到每条字节码指令时如何处理并给出了最终的处理结果，但是并没有规定执行引擎应该采取什么处理方式。执行引擎具体采取什么方式由JVM的实现厂商决定。==对于JVM来说，主要采用的方式是解释执行和编译执行==。
==每个Java线程就是一个执行引擎的实例==，在一个JVM实例中同时有多个执行引擎在工作，这些执行引擎有的在执行用户的程序，有的在执行JVM内部的程序。

### 3.内存空间

==执行引擎在执行Class文件的字节码时需要存储相关的信息，如操作码需要的操作数和操作码的执行结果等==。Class文件的字节码和涉及的类的对象等信息需要在执行引擎执行之前准备好。从图1-1中可以看出，==JVM的内存空间主要由Java堆、Java栈、本地方法栈和PC寄存器构成==。其中

- ==Java堆是所有线程共享的==，也就是可以被所有的执行引擎实例访问。
- ==每个新的执行引擎实例被创建时会为这个执行引擎创建一个Java栈==，如果当前正在执行一个Java方法，那么在当前的Java栈中保存的是该线程中方法调用的状态，包括方法的参数、局部变量和返回值等。
- ==PC寄存器用于保存当前线程执行的内存地址==。由于JVM程序是多线程执行的（线程轮流切换）,为了保证线程切换回来后还能恢复到原先的状态，需要一个独立的计数器记录之前中断的地方，所以==PC寄存器也是线程私有的==。

### 4.垃圾收集器

==垃圾收集器==一般完成两件事，即==标记不再使用的对象和回收这些无用对象==。不同厂商及相同厂商的不同JVM版本提供的垃圾收集器可能不同，例如OpenJDK8主要包含的垃圾收集器如图1-2所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20230511/image.1l3y0pi5y0lc.webp)

图1-2中的连线表示可以使用连线两端的两种收集器分别收集年轻代和老年代的内存空间，而G1收集器既可以收集年轻代的内存空间，也可以收集老年代的内存空间。
